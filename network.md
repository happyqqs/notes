# HTTP



### 版本

#### 0.9

第一个版本，已过时，组成及其简单，只允许客户端发送GET请求，不支持请求头。所以只支持纯文本

具有典型的无状态性，每个事务独立进行处理，事务结束时就释放这个连接；由此可见，HTTP协议的无状态特点在其第一个版本0.9中已经成型；一次HTTP/0.9的传输首先要建立一个由客户端到Web服务器的TCP连接，由客户端发起一个请求，然后由Web服务器返回页面内容，然后连接会关闭；如果请求的页面不存在，也不会返回任何错误码；

#### 1.0

HTTP协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用；相对于HTTP/0.9增加了如下主要特性：

1. 请求与响应支持头域
2. 响应对象以一个响应状态行开始
3. 响应对象不只限于超文本
4. 开始支持客户端通过POST方法向Web服务器提交数据，支持GET、HEAD、POST方法
5. 支持长连接（但默认还是使用短连接），缓存机制，以及身份认证

#### 1.1

HTTP协议的第三个版本是HTTP/1.1，是目前使用最广泛的协议版本；HTTP/1.1是目前主流的HTTP协议版本，相对于HTTP/1.0新增了以下内容：

1. 默认为长连接

   **HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection：keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点；**

2. 提供了范围请求功能（宽带优化）

   HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，**HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接；这是支持文件断点续传的基础；**

3. 提供了虚拟主机的功能（HOST域）

   在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）；但**随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址；HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）；**

4. 多了一些缓存处理字段

   HTTP/1.1在1.0的基础上加入了一些cache的新特性，引入了实体标签，一般被称为e-tags，新增更为强大的Cache-Control头；

5. 错误通知的管理

   在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除；

#### 2.0

HTTP协议的第四个版本是HTTP/2.0，相对于HTTP/1.1新增了以下内容：

1. 二进制分帧

   HTTP 2.0 的所有帧都采用二进制编码

   - 帧：客户端与服务器通过交换帧来通信，帧是基于这个新协议通信的最小单位；
   - 消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成；
   - 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2 … N）；

2. 多路复用

   多路复用允许同时通过单一的HTTP/2.0 连接发起多重的请求-响应消息。有了新的分帧机制后，HTTP/2.0不再依赖多个TCP 连接去处理更多并发的请求；每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级；最后再在另一端根据每个帧首部的流标识符把它们重新组合起来；HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可；

3. 头部压缩

   HTTP/1.1 的首部带有大量信息，而且每次都要重复发送；HTTP/2.0 要求通讯双方各自缓存一份首部字段表，从而避免了重复传输；

4. 请求优先级

   浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序；这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接；

5. 服务端推送

   服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤；正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度；



## HTTPS

http over tls/ssl

https相比http提供了

* 数据完整性：内容传输经过完整性校验
* 数据保密性：内容经过对称加密，每个连接生成一个唯一的加密密钥
* 身份认证：第三方无法伪造服务端（客户端）身份

TLS/SSL握手过程：

1. Client Hello：客户端生成的随机数**random1**，客户端支持的加密套件Ciphers，协议版本
2. Server Hello：服务端生成的随机数**random2**，从Ciphers中选取的一份加密套件
3. Certificate：服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。
4. Server Key Exchange：如果是DH算法，这里发送服务器使用的DH参数。RSA算法不需要这一步。
5. Certificate Request：服务端要求客户端上报证书，这一步是可选的，对于安全性要求高的场景会用到。
6. Server Hello Done： 通知客户端 Server Hello 过程结束。
7. Certificate Verify：客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 **Random3**，再用服务端公钥非对称加密 **Random3**生成 **PreMaster Key**。
8. Client Key Exchange：上面客户端根据服务器传来的公钥生成了 **PreMaster Key**，Client Key Exchange 就是将这个 key 传给服务端，服务端再用自己的私钥解出这个 **PreMaster Key** 得到客户端生成的 **Random3**。至此，客户端和服务端都拥有 **Random1** + **Random2** + **Random3**，两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。为什么要使用三个随机数呢？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来
9. Change Cipher Spec(Client)：这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息
10. Encrypted Handshake Message(Client)：这一步对应的是 Client Finish 消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的。
11. Change Cipher Spec(Server)：这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。
12. Encrypted Handshake Message(Server)：这一步对应的是 Server Finish 消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。

到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。

握手过程优化：

如果每次重连都要重新握手还是比较耗时的，所以可以对握手过程进行优化。Client Hello 消息里还附带了上一次的 Session ID，服务端接收到这个 Session ID 后如果能复用就不再进行后续的握手过程。

#### 证书和CA



#### 中间人攻击

#### charels https抓包

核心思想：

1. 构造一个中间人代理，有能力完成TLS/SSL握手
2. 弄到一个根证书，并用它生成签名认证的代理服务器证书





# TCP



 # UDP



